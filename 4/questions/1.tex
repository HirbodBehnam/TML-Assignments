\section{ماشین تورینگ}
\subsection{}
\subsubsection{}
الفبا ماشین را به صورت زیر تعریف می‌کنیم:
\begin{align*}
    \Sigma &= \{a\}\\
    \Gamma &= \{a, \sqcup\}\\
\end{align*}
ایده‌ی اصلی برای حل این سوال این است که در ابتدا دو تا دو تا علامت‌های
$a$
را بخوانیم. اگر در آخر هیچ علامتی نماند رشته را قبول می‌کنیم ولی در غیر این صورت
(یک $a$ ماند)
به اول رشته می‌رویم و این بار سه تا سه تا خط می‌زنیم. این کار را با پنج تا پنج‌تا نیز انجام می‌دهیم 
و اگر 5 نیز جواب نداد جواب را
\lr{reject}
می‌کنیم.
\subsubsection{}
الفبا ماشین را به صورت زیر تعریف می‌کنیم:
\begin{align*}
    \Sigma &= \{a, b\}\\
    \Gamma &= \{a, b, \cancel{a}, \cancel{b}, \sqcup\}\\
\end{align*}
نکته‌ای که در این سوال وجود دارد این است که داریم:
\begin{gather*}
    n^2 = 1 + 3 + 5 + \dots + (2n - 1)
\end{gather*}
مراحل برای کارکرد این ماشین به صورت زیر است:
\begin{enumerate}
    \item اگر رشته تهی بود آنرا قبول کن.
    \item در غیر این صورت صرفا چک کن که آیا رشته به صورت
    $a^*b^*$
    است یا خیر. در صورتی که رشته به صورت فوق نبود آنرا رد کن.
    \item اولین $a$ را تبدیل به $\cancel{a}$
    بکن. سپس اینقدر جلو برو و یک
    $b$ را نیز خط بزن. در صورتی که $b$ای وجود نداشت \lr{reject} بکن.
    \item به اولین $a$ خط نخورده برگرد و آنرا خط بزن. سپس به اندازه‌ی
    $2n-1$
    برابر تعداد کل
    $\cancel{a}$ها
    (از اول اجرای‌ ماشین)
    تا حالا
    $b$
    خط بزن. اگر تعداد
    $b$ها کم آمد
    \lr{reject}
    کن. برای به تعداد
    $2n-1$
    بار خط زدن می‌توان به تعداد
    $2(n-1) + 1$
    بار خط زد. برای این کار به تعداد
    $a$هایی که از قبل خط خورده بودند، دوبرابر آنها
    $b$
    خط می‌زنیم.
    (این کار را صرفا می‌توان به صورتی کرد که به ازای هر $a$ درجا دو $b$ خط بزنیم و برگردیم به سمت $a$ها (زیگزاگی))
    در نهایت یک $b$ اضافه نیز خط می‌زنیم.
    \item مرحله‌ی قبل را اینقدر ادامه بده تا اینکه $a$ها تمام شوند.
    اگر تمامی
    $b$ها
    خط خورده بودند رشته را قبول کن وگرنه آنرا رد کن.
\end{enumerate}
\subsection{}
\subsubsection{}
بدیهی است که یک ماشین تورینگ کلاسیک یک ماشین تورینگ چند بعدی با
$k = 1$
است. حال از استقرا استفاده می‌کنیم. پایه‌ی استقرا که مشخص است که یک ماشین تورینگ یک بعدی را می‌توان
دقیقا به یک ماشین تورینگ کلاسیک داد و آنرا اجرا کرد. تنها تفاوتی که دارد این است که در هر مرحله
\lr{head}
می‌تواند
$n$
بار به چپ یا راست برود که صرفا در ماشین تورینگ کافی است که 
$n$
بار با هر ورودی خاصی
\lr{head}
را به چپ یا راست ببریم.
حال به کمک استقرا فرض می‌کنیم که می‌توانیم یک ماشین تورینگ
$n$
بعدی را با یک ماشین تورینگ کلاسیک مدل کنیم. حال باید سعی کنیم که یک ماشین تورینگ
$n+1$
بعدی را به کمک
$n$
بعدی بسازیم.

برای این کار، در ابتدا حرفی را انتخاب می‌کنیم که توسط ماشین‌های دیگر مورد استفاده نباشد. برای مثال من از
$\#$
استفاده می‌کنم. می‌دانیم که ماشین از حالت
$(0, \underbrace{0, 0, \dots, 0}_{n})$
شروع می‌کند. تا زمانی که ماشین در حالت‌های
$(0, a_1, a_2, \dots, a_n)$
است صرفا از
\lr{tape}
استفاده می‌کنیم که ماشین
$n$
بعدی را شبیه سازی کنیم. حال فرض کنید که به حالت
$(1, b_1, b_2, \dots, b_n)$
می‌خواهیم بریم. برای این کار
(دقت کنید از حالتی می‌خواهیم برویم که اولین بعد ما 0 باشد)
به آخر نوار می‌رویم و
$\#$
را قرار می‌دهیم. سپس در ادامه‌ی آن یک ماشین
$n$
بعدی را
\lr{initialize}
می‌کنیم. سپس
\lr{transition}
$\forall s \in \Sigma, s \rightarrow s \times (b_1, b_2, \dots, b_n)$
را اجرا می‌کنیم. به عبارتی دیگر بدون اینکه به نوار دست بزنیم به خانه‌ی
$(b_1, b_2, \dots, b_n)$
داخل
\lr{tape}
ماشین تورینگ
$n$
بعدی می‌رویم. سپس از آن خانه شبیه سازی را ادامه می‌دهیم. نکته‌ی دیگری که وجود دارد این است که اگر می‌خواستیم به
$(-1, b_1, b_2, \dots, b_n)$
برویم باید چه کار می‌کردیم. در این حالت باید یک
$\#$
به اول رشته اضافه می‌کردیم و کل محتوای بعد آن را به راست شیفت می‌دادیم.

یک احتمال دیگر که وجود دارد این است که مثلا از حالت اولیه بخواهیم به حالت
$(c, b_1, b_2, \dots, b_n)$
برویم. برای این حالت اینقدر
\lr{head}
را به سمت راست
(یا چپ اگر $c$ منفی باشد)
می‌بریم که
$c$تا
$\#$
ببینیم. اگر بعد از مدتی به قسمت خالی نوار رسیدیم، باید صرفا به تعداد باقی مانده ماشین تورینگ
$n$
بعدی بسازیم و بعد از آنها
$\#$
قرار دهیم.

یک نکته‌ی دیگر که باید توجه کنیم این است که بین دو
$\#$
نیاز به فضای بیشتر داشتیم باید از سمت راست همه چیز را شیفت دهیم.

به صورت کلی در این مثال داریم که تا حدودی مثل ماشین تورینگ چند نواره عمل می‌کنیم با این تفاوت که یکی
\lr{lazy allocation}
داریم می‌کنیم، و دیگری اینکه نوار از چپ نیز می‌تواند بزرگ شود. ولی اگر بخواهیم انرا از چپ بزرگ کنیم صرفا
کافی است که همه چیز را به راست شیفت دهیم. همچنین وقتی که یک
\lr{sub machine}
را انتخاب می‌کنیم در ابتدا باید آنرا به حالت 0 ریست کنیم و سپس به حالت
\lr{absolute}
بعدی برویم.
\subsubsection{}
کاری که باید انجام دهیم این است که در ابتدا مجموعه‌ی
$S$
را برابر تمام اعداد حقیقی که بر روی آن‌ها چیزی نوشته شده است قرار می‌دهیم. سپس مجموعه‌ی
$T$
را پیدا می‌کنیم. سپس ماشین تورینگی تشکیل می‌دهیم که
$|S| \times |T|$
نوار داشته باشد. عملا می‌توان به صورت برنامه نویسی این ماشین را به صورت
\codeword{TAPE tm\_tapes[S][T]}
نوشت. برای پیدا کردن عدد دوم به عنوان مثال می‌توان محتوای تمامی
\lr{tape}های
\codeword{tm\_tapes[2]}
نگاه کرد که یک آرایه از نوارها هستند. هر یک از این نوار‌ها را بدین صورت کد می‌کنیم که تنها یک خانه‌ی
غیر خالی دارند که خانه‌ی
$a_i$ام
است که در آن خانه چیزی که در ماشین تورینگ حقیقی نوشته شده بود نوشته شده است.
به کمک این ماشین می‌توان تمامی اعداد حقیقی را
\lr{decode}
کرد.
نکته‌ای که وجود دارد این است که
$S$
می‌تواند بزرگتر شود. در صورتی که این
$S$
بزرگتر شود باید یک مجموعه‌ی
$T$
جدید ساخت. دقت کنید که به خاطر قضیه‌ی
\lr{universal computing machine}
می‌توان تمام این ماشین‌ها را
\lr{unfly}
ساخت.